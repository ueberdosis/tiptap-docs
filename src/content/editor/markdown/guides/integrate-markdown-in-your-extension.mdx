---
title: Integration Markdown in Custom Extensions
tags:
  - type: beta
meta:
  title: Markdown Extension Integration | Tiptap Editor Docs
  description: Learn how to integrate markdown support into your custom Tiptap extensions. This guide covers extending parsing and serialization for custom nodes and marks.
  category: Editor
---

This guide shows you how to add markdown support to your Tiptap extensions.

**Tip**: For standard patterns like Pandoc blocks (`:::name`) or shortcodes (`[name]`), check out the [Utility Functions](../api/utilities) to generate markdown specs with minimal code.

## Basic Extension Integration

To add markdown support to an extension, define a `markdown` object in your extension configuration:

```typescript
import { Node } from '@tiptap/core'

const MyNode = Node.create({
  name: 'myNode',

  // ... other configuration (parseHTML, renderHTML, etc.)

  markdown: {
    parse: (token, helpers) => {
      /* ... */
    },
    render: (node, helpers) => {
      /* ... */
    },
  },
})
```

## The Markdown Configuration Object

The `markdown` object can contain these properties:

```typescript
type ExtendableMarkdownSpec = {
  parseName?: string // Token name for parsing
  renderName?: string // Node type name for rendering
  parse?: (token, helpers) => MarkdownParseResult
  render?: (node, helpers, context) => string
  isIndenting?: boolean // Whether this node increases indent level
  tokenizer?: MarkdownTokenizer // Custom tokenizer
}
```

- `parseName` (string): The token name from marked.js to handle. Required if `parse` is defined.
- `renderName` (string): The Tiptap node type name to match when rendering. Required if `render` is defined.
- `parse` (function): Function to convert a marked.js token to a Tiptap node. Receives the token and helper functions.
- `render` (function): Function to convert a Tiptap node to a markdown string
- `isIndenting` (boolean): For list nodes, indicates if this node increases the indentation level for nested items.
- `tokenizer` (object): Define a custom tokenizer to recognize new markdown syntax.

### Using `parseName` and `renderName`

```typescript
markdown: {
  parseName: 'strong',   // Match 'strong' tokens when parsing
  renderName: 'bold',    // Use when rendering 'bold' nodes

  parse: (token, helpers) => { /* ... */ },
  render: (node, helpers) => { /* ... */ },
}
```

## Node Extensions

Creating markdown support for nodes is straightforward. Here are some common patterns.

Depending on the type of content you expect, you may need to use different helper functions in your `parseMarkdown` and `renderMarkdown` methods.

- If your extension is a node with block-level content, use `helpers.parseChildren` and `helpers.renderChildren`.
- If your extension is a node with inline-level content, use `helpers.parseInline` and `helpers.renderChildren`.

```typescript
import { Node } from '@tiptap/core'

const Heading = Node.create({
  name: 'heading',

  group: 'block',
  content: 'inline*',

  parseHTML() {
    return [{ tag: 'p' }]
  },

  renderHTML() {
    return ['p', 0]
  },

  markdown: {
    parse: (token, helpers) => {
      const level = token.depth || 1

      const content = helpers.parseInline(token.tokens || []) // we parse inline here because headings contain inline content
      return {
        type: 'heading',
        attrs: { level },
        content,
      }
    },

    render: (node, helpers) => {
      const level = node.attrs?.level || 1
      const prefix = '#'.repeat(level)

      const content = helpers.renderChildren(node.content || [])
      return `${prefix} ${content}`
    },
  },
})
```

## Mark Extensions

Marks work differently because they wrap inline content. To add markdown support to your mark extensions, use the `applyMark` and `renderChildren` helper functions.

```typescript
import { Mark } from '@tiptap/core'

const Bold = Mark.create({
  name: 'bold',

  parseHTML() {
    return [{ tag: 'strong' }, { tag: 'b' }]
  },

  renderHTML() {
    return ['strong', 0]
  },

  markdown: {
    name: 'strong',

    parse: (token, helpers) => {
      // Parse the content and apply the bold mark
      const content = helpers.parseInline(token.tokens || [])
      return helpers.applyMark('bold', content)
    },

    render: (node, helpers) => {
      const content = helpers.renderChildren(node.content || [])
      return `**${content}**`
    },
  },
})
```

If you want to apply attributes to your marks, use the `applyMark` helper with an attributes object.

```typescript
const content = helpers.applyMark('link', helpers.parseInline(token.tokens || []), {
  href: token.href || '',
  title: token.title || null,
})
```

## Testing Your Extension

### Unit Test Parse Handler

```typescript
import { describe, it, expect } from 'vitest'

describe('Heading markdown', () => {
  it('should parse heading tokens', () => {
    const token = {
      type: 'heading',
      depth: 2,
      tokens: [{ type: 'text', text: 'Hello' }],
    }

    const helpers = {
      parseInline: tokens => [{ type: 'text', text: 'Hello' }],
    }

    const result = Heading.options.markdown.parse(token, helpers)

    expect(result).toEqual({
      type: 'heading',
      attrs: { level: 2 },
      content: [{ type: 'text', text: 'Hello' }],
    })
  })
})
```

### Unit Test Render Handler

```typescript
describe('Heading markdown', () => {
  it('should render heading nodes', () => {
    const node = {
      type: 'heading',
      attrs: { level: 2 },
      content: [{ type: 'text', text: 'Hello' }],
    }

    const helpers = {
      renderChildren: () => 'Hello',
    }

    const result = Heading.options.markdown.render(node, helpers, {})

    expect(result).toBe('## Hello\n\n')
  })
})
```

### Integration Test

```typescript
import { Editor } from '@tiptap/core'
import { Markdown } from '@tiptap/markdown'
import MyExtension from './MyExtension'

describe('MyExtension integration', () => {
  it('should parse and serialize correctly', () => {
    const editor = new Editor({
      extensions: [Document, Paragraph, Text, MyExtension, Markdown],
    })

    const markdown = '# Hello World'
    editor.commands.setContent(markdown, { asMarkdown: true })

    const json = editor.getJSON()
    expect(json.content[0].type).toBe('heading')

    const result = editor.getMarkdown()
    expect(result).toBe('# Hello World\n\n')

    editor.destroy()
  })
})
```

## Common Patterns

### Handle Optional Token Properties

```typescript
parse: (token, helpers) => {
  return {
    type: 'myNode',
    attrs: {
      level: token.depth || 1, // Default if missing
      id: token.id ?? null, // Nullish coalescing
      text: token.text?.trim() || '', // Optional chaining
    },
    content: helpers.parseInline(token.tokens || []),
  }
}
```

### Conditional Parsing

```typescript
parse: (token, helpers) => {
  // Only handle specific types
  if (token.ordered) {
    return null // Let another handler process it
  }

  // Or use different logic based on token properties
  if (token.depth > 6) {
    // Treat as paragraph instead
    return {
      type: 'paragraph',
      content: helpers.parseInline(token.tokens || []),
    }
  }

  return {
    type: 'heading',
    attrs: { level: token.depth },
    content: helpers.parseInline(token.tokens || []),
  }
}
```

### Context-Aware Rendering

```typescript
render: (node, helpers, context) => {
  const content = helpers.renderChildren(node.content || [])

  // Adjust rendering based on context
  if (context.level > 0) {
    // Nested - add extra indentation
    return helpers.indent(`- ${content}`) + '\n'
  }

  // Top-level
  return `- ${content}\n`
}
```
