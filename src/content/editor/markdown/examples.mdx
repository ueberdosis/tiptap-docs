---
title: Markdown Examples
tags:
  - type: beta
meta:
  title: Markdown Examples | Tiptap Editor Docs
  description: Explore practical examples of using the Markdown extension in Tiptap. Learn how to parse, serialize, and customize markdown content in your editor.
  category: Editor
---

Real-world examples and recipes for common use cases with the Markdown extension.

## Basic Examples

### Read and Write Markdown

This example demonstrates the most common markdown operations:

```typescript
import { Editor } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import { Markdown } from '@tiptap/markdown'

const editor = new Editor({
  element: document.querySelector('#editor'),
  extensions: [StarterKit, Markdown],
  content: '# Hello World\n\nStart typing...',
  contentAsMarkdown: true, // parse initial content as markdown
})

// Read: serialize current editor content to Markdown
console.log(editor.getMarkdown())

// Write: set editor content from a Markdown string
editor.commands.setContent('# New title\n\nSome *markdown* content', { asMarkdown: true })
```

---

### Paste Markdown Detection

Automatically detect and parse pasted markdown:

```typescript
import { Editor } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import { Markdown } from '@tiptap/markdown'
import { Plugin } from '@tiptap/pm/state'

const PasteMarkdown = Extension.create({
  name: 'pasteMarkdown',

  addProseMirrorPlugins() {
    return [
      new Plugin({
        props: {
          handlePaste(view, event, slice) {
            const text = event.clipboardData?.getData('text/plain')

            if (!text) {
              return false
            }

            // Check if text looks like markdown
            if (looksLikeMarkdown(text)) {
              const { state, dispatch } = view
              // Parse the markdown text to Tiptap JSON using the markdown manager
              const json = editor.markdown.parse(text)

              // Insert the parsed JSON content at cursor position
              editor.commands.insertContent(json)
              return true
            }

            return false
          },
        },
      }),
    ]
  },
})

function looksLikeMarkdown(text: string): boolean {
  // Simple heuristic: check for markdown syntax
  return (
    /^#{1,6}\s/.test(text) || // Headings
    /\*\*[^*]+\*\*/.test(text) || // Bold
    /\[.+\]\(.+\)/.test(text) || // Links
    /^[-*+]\s/.test(text)
  ) // Lists
}

const editor = new Editor({
  extensions: [StarterKit, Markdown, PasteMarkdown],
})
```

## Custom Tokenizers

### Subscript and Superscript

Support `~subscript~` and `^superscript^`:

```typescript
import { Mark } from '@tiptap/core'

export const Subscript = Mark.create({
  name: 'subscript',

  parseHTML() {
    return [{ tag: 'sub' }]
  },

  renderHTML() {
    return ['sub', 0]
  },

  markdown: {
    name: 'subscript',

    // Custom tokenizer for ~text~ subscript syntax
    tokenizer: {
      name: 'subscript',
      level: 'inline',
      start: (src) => src.indexOf('~'),
      tokenize: (src, tokens, lexer) => {
        const match = /^~([^~]+)~/.exec(src)
        if (!match) return undefined

        return {
          type: 'subscript',
          raw: match[0], // Full match: ~text~
          text: match[1], // Content: text
          tokens: lexer.inlineTokens(match[1]), // Parse nested inline formatting
        }
      },
    },

    // Parse token and apply subscript mark to content
    parse: (token, helpers) => {
      const content = helpers.parseInline(token.tokens || [])
      return helpers.applyMark('subscript', content)
    },

    // Render back to ~text~ syntax
    render: (node, helpers) => {
      const content = helpers.renderChildren(node.content || [])
      return `~${content}~`
    },
  },
})

export const Superscript = Mark.create({
  name: 'superscript',

  parseHTML() {
    return [{ tag: 'sup' }]
  },

  renderHTML() {
    return ['sup', 0]
  },

  markdown: {
    name: 'superscript',

    // Custom tokenizer for ^text^ superscript syntax
    tokenizer: {
      name: 'superscript',
      level: 'inline',
      start: (src) => src.indexOf('^'),
      tokenize: (src, tokens, lexer) => {
        const match = /^\^([^^]+)\^/.exec(src)
        if (!match) return undefined

        return {
          type: 'superscript',
          raw: match[0], // Full match: ^text^
          text: match[1], // Content: text
          tokens: lexer.inlineTokens(match[1]), // Parse nested inline formatting
        }
      },
    },

    // Parse token and apply superscript mark to content
    parse: (token, helpers) => {
      const content = helpers.parseInline(token.tokens || [])
      return helpers.applyMark('superscript', content)
    },

    // Render back to ^text^ syntax
    render: (node, helpers) => {
      const content = helpers.renderChildren(node.content || [])
      return `^${content}^`
    },
  },
})
```

Usage:

```typescript
editor.commands.setContent('H~2~O and E = mc^2^', { asMarkdown: true })
```

## Integration Examples

### Real-Time Markdown Preview

You can create a real-time markdown preview by listening to editor updates:

```typescript
import { Editor } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import { Markdown } from '@tiptap/markdown'

const editor = new Editor({
  extensions: [StarterKit, Markdown],
  content: '# Hello',
  onUpdate: ({ editor }) => {
    const markdown = editor.getMarkdown()
    updatePreview(markdown) // Your preview update function
  },
})

function updatePreview(markdown) {
  document.querySelector('#preview').textContent = markdown
}
```

### Saving and Loading Workflow

Store content as markdown and load it when needed:

```typescript
// Save to database/storage
async function saveContent() {
  const markdown = editor.getMarkdown()
  await fetch('/api/save', {
    method: 'POST',
    body: JSON.stringify({ content: markdown }),
  })
}

// Load from database/storage
async function loadContent() {
  const { content } = await fetch('/api/load').then((r) => r.json())
  editor.commands.setContent(content, { asMarkdown: true })
}
```

## Server-Side Rendering

Render markdown on the server:

```typescript
import StarterKit from '@tiptap/starter-kit'
import { MarkdownManager } from '@tiptap/markdown'
import { generateHTML } from '@tiptap/html'

const markdownManager = new MarkdownManager({
  extensions: [StarterKit, Markdown], // Include Markdown extension
})

// Parse markdown to JSON on server
function parseMarkdown(markdown: string) {
  return editor.markdownManager.parse(markdown)
}

// Convert JSON to HTML for rendering
function renderToHTML(json: JSONContent) {
  // Generate HTML from Tiptap JSON (no markdown involved here)
  return generateHTML(json, [StarterKit])
}

// Full pipeline: Markdown → JSON → HTML
function markdownToHTML(markdown: string) {
  const json = parseMarkdown(markdown) // Parse markdown to JSON
  return renderToHTML(json) // Render JSON to HTML
}

// Express route example
app.get('/document/:id', async (req, res) => {
  const doc = await db.getDocument(req.params.id)
  const json = parseMarkdown(doc.markdown) // Parse stored markdown
  const html = renderToHTML(json) // Convert to HTML for display

  res.render('document', { content: html })
})
```

---

## Advanced Patterns

### Lazy Loading Large Documents

Load large documents progressively:

```typescript
async function loadLargeDocument(documentId: string) {
  // Load metadata first
  const meta = await fetchDocumentMeta(documentId)

  // Show skeleton
  showSkeleton()

  // Load in chunks
  const chunks = await fetchDocumentChunks(documentId, meta.chunkCount)

  // Parse each markdown chunk and insert at correct position
  for (const chunk of chunks) {
    const json = editor.markdown.parse(chunk.markdown) // Parse markdown to JSON
    editor.commands.insertContentAt(chunk.position, json) // Insert at position
  }

  hideSkeleton()
}
```
