---
title: Schema awareness
meta:
  title: Schema awareness | Tiptap Content AI
  description: Give schema awareness to your AI model so it understands nodes, marks, and attributes in the Server AI Toolkit.
  category: Content AI
---

import { Callout } from '@/components/ui/Callout'

A Tiptap [schema](/editor/core-concepts/schema) describes the elements the document can (and cannot) contain. Tiptap's **schema awareness** capabilities allow AI models to understand the document better when using the Server AI Toolkit.

<Callout title="Why schema awareness?" variant="default">
  Without schema awareness, the AI model might generate content that the Tiptap editor does not
  support. For example, it might generate a table in a document that does not support tables. With
  schema awareness enabled, the AI model will know that table nodes are not supported and will
  refuse to generate them.
</Callout>

## Guide: give schema awareness to your AI model

Integrate the schema awareness feature to an AI agent like the one built in the [AI agent chatbot guide](/content-ai/capabilities/server-ai-toolkit/agents/ai-agent-chatbot).

### Step 1: get the schema awareness data

Get the schema awareness data from the Server AI Toolkit package. This data contains information about the document's schema in a format optimized for the AI model.

```ts
import { Editor } from '@tiptap/core'
import StarterKit from '@tiptap/starter-kit'
import { getSchemaAwarenessData } from '@tiptap-pro/server-ai-toolkit'

const editor = new Editor({
  extensions: [StarterKit],
})

// Retrieve the schema awareness data
const schemaAwarenessData = getSchemaAwarenessData(editor)
```

The `getSchemaAwarenessData` function returns schema awareness data that describes the document structure for the Server AI Toolkit API.

<Callout title="Store the schema awareness data" variant="info">
  The schema awareness data returned by `getSchemaAwarenessData` is a JSON-serializable object that
  you can store in your database. You don't need to generate it every timeâ€”only update it when your
  Editor extensions or schema change.
</Callout>

### Step 2 (optional): configure custom nodes

If your document contains [custom Nodes and Marks](/editor/extensions/custom-extensions), add the `addJsonSchemaAwareness` option to the extension configuration. This way, the AI model will be able to generate this custom Node or Mark accurately.

For example, if you have a custom node called `'alert'`, you can allow the AI model to generate it by configuring it like this:

```ts
import { Node } from '@tiptap/core'
import { z } from 'zod'

const CustomExtension = Node.create({
  name: 'alert',

  addAttributes() {
    return {
      type: {
        default: 'info',
        parseHTML: (element) => element.getAttribute('data-type'),
        renderHTML: (attributes) => {
          if (!attributes.type) {
            return {}
          }
          return {
            'data-type': attributes.type,
          }
        },
      },
    }
  },

  addJsonSchemaAwareness() {
    return {
      name: 'Alert Box',
      description: `A highlighted box used to display important information, warnings, or tips to the user.
It can contain inline content like text and formatting marks.`,
      attributes: {
        type: z
          .enum(['info', 'warning', 'error', 'success'])
          .describe(
            'The type of alert. Can be one of these 4 values: info, warning, error, or success',
          ),
      },
    }
  },

  parseHTML() {
    return [
      {
        tag: 'div[data-alert]',
      },
    ]
  },

  renderHTML({ HTMLAttributes }) {
    return ['div', { ...HTMLAttributes, 'data-alert': '' }, 0]
  },

  // ... Other extension configuration options
})
```

The `addJsonSchemaAwareness` function should return an object with:

- `name` (`string`): The human-readable name of the element in English
- `description?` (`string`): Explanation of the element in English for the AI model
- `attributes?` (`Record<string, z.ZodTypeAny>`): Possible attributes of the element, defined as Zod schemas that will be converted to JSON schemas

<Callout title="What about official Tiptap extensions?" variant="info">
  Schema awareness for official Tiptap extensions is automatically supported by the Server AI
  Toolkit. They do not need to be configured. You can still override the default schema awareness
  information for official Tiptap extensions by extending the extension and adding the
  `addJsonSchemaAwareness` option.
</Callout>

### Step 3: pass schema awareness data to the API

When you call the Server AI Toolkit API endpoints, include the schema awareness data in the request body. The Server AI Toolkit API also provides a schema awareness prompt that should be included in the AI model's instructions.

Create helper functions to interact with the Server AI Toolkit API. These functions handle fetching tool definitions, schema awareness prompts, and executing tools:

### Constants

The constants file centralizes all environment variables and configuration values used across the API route and helper functions.

```ts
// app/api/server-ai-agent-chatbot/constants.ts
export const API_BASE_URL = process.env.SERVER_AI_TOOLKIT_API_URL || 'https://api.tiptap.dev'
export const JWT_TOKEN = process.env.SERVER_AI_TOOLKIT_JWT_TOKEN
export const APP_ID = process.env.SERVER_AI_TOOLKIT_APP_ID
export const REST_API_SECRET = process.env.REST_API_SECRET
export const TIPTAP_CLOUD_APP_ID = process.env.TIPTAP_CLOUD_APP_ID
```

### Get tool definitions

This function fetches the available tool definitions from the Server AI Toolkit API.

```ts
// app/api/server-ai-agent-chatbot/get-tool-definitions.ts
import type z from 'zod'
import { API_BASE_URL, APP_ID, JWT_TOKEN } from './constants'

export async function getToolDefinitions(schemaAwarenessData: unknown): Promise<
  {
    name: string
    description: string
    inputSchema: z.core.JSONSchema.JSONSchema
  }[]
> {
  const response = await fetch(`${API_BASE_URL}/v2/toolkit/tools`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${JWT_TOKEN}`,
      'X-App-Id': APP_ID || '',
    },
    body: JSON.stringify({
      schemaAwarenessData,
    }),
  })

  if (!response.ok) {
    throw new Error(`Failed to fetch tools: ${response.statusText}`)
  }
  const responseData = await response.json()

  return responseData.tools
}
```

### Get schema awareness prompt

This function retrieves a formatted prompt string from the Server AI Toolkit API that describes the document's schema to the AI model. This prompt is included in the agent's instructions to help the AI understand what nodes, marks, and attributes are available in the document.

```ts
// app/api/server-ai-agent-chatbot/get-schema-awareness-prompt.ts
import { API_BASE_URL, APP_ID, JWT_TOKEN } from './constants'

export async function getSchemaAwarenessPrompt(schemaAwarenessData: unknown): Promise<string> {
  const response = await fetch(`${API_BASE_URL}/v2/toolkit/schema-awareness-prompt`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${JWT_TOKEN}`,
      'X-App-Id': APP_ID || '',
    },
    body: JSON.stringify({
      schemaAwarenessData,
    }),
  })

  if (!response.ok) {
    throw new Error(`Failed to fetch schema awareness prompt: ${response.statusText}`)
  }

  const result: { prompt: string } = await response.json()
  return result.prompt
}
```

### Execute tool

This function executes a tool via the Server AI Toolkit API. It sends the tool name, input parameters, current document state, and schema awareness data to the API, which processes the tool execution and returns the result along with an updated document if the tool modified it.

```ts
// app/api/server-ai-agent-chatbot/execute-tool.ts
import { API_BASE_URL, APP_ID, JWT_TOKEN } from './constants'

export async function executeTool(
  toolName: string,
  input: unknown,
  document: unknown,
  schemaAwarenessData: unknown,
): Promise<{ output: unknown; docChanged: boolean; document?: unknown }> {
  const response = await fetch(`${API_BASE_URL}/v2/toolkit/execute-tool`, {
    method: 'POST',
    headers: {
      'Content-Type': 'application/json',
      Authorization: `Bearer ${JWT_TOKEN}`,
      'X-App-Id': APP_ID || '',
    },
    body: JSON.stringify({
      toolName,
      input,
      document,
      schemaAwarenessData, // Include schema awareness data
    }),
  })

  if (!response.ok) {
    throw new Error(`Tool execution failed: ${response.statusText}`)
  }

  return response.json()
}
```

### Get document

This function retrieves the current document state from Tiptap Cloud's REST API using the document ID. It's called before each tool execution to ensure the tool operates on the latest version of the document, preventing conflicts with concurrent edits.

```ts
// app/api/server-ai-agent-chatbot/get-document.ts
import { REST_API_SECRET, TIPTAP_CLOUD_APP_ID } from './constants'

export async function getDocument(documentId: string): Promise<unknown> {
  if (!TIPTAP_CLOUD_APP_ID || !REST_API_SECRET) {
    throw new Error('Missing TIPTAP_CLOUD_APP_ID or REST_API_SECRET')
  }

  const collabUrl = `https://${TIPTAP_CLOUD_APP_ID}.collab.tiptap.cloud/api/documents/${encodeURIComponent(
    documentId,
  )}?format=json`

  const response = await fetch(collabUrl, {
    method: 'GET',
    headers: {
      'Content-Type': 'application/json',
      Authorization: REST_API_SECRET,
    },
  })

  if (!response.ok) {
    if (response.status === 404) {
      throw new Error(`Document ${documentId} not found`)
    }
    throw new Error(`Failed to retrieve document: ${response.status} ${response.statusText}`)
  }

  return response.json()
}
```

### Update document

This function updates the document state in Tiptap Cloud's REST API after a tool execution has modified it. It attempts to patch the existing document, and if the document doesn't exist (404), it creates a new one. This ensures the document state is persisted and synchronized across all clients.

```ts
// app/api/server-ai-agent-chatbot/update-document.ts
import { REST_API_SECRET, TIPTAP_CLOUD_APP_ID } from './constants'

export async function updateDocument(documentId: string, document: unknown): Promise<void> {
  if (!TIPTAP_CLOUD_APP_ID || !REST_API_SECRET) {
    console.warn('Missing TIPTAP_CLOUD_APP_ID or REST_API_SECRET, skipping update')
    return
  }

  const collabUrl = `https://${TIPTAP_CLOUD_APP_ID}.collab.tiptap.cloud/api/documents/${encodeURIComponent(
    documentId,
  )}?format=json`

  try {
    const response = await fetch(collabUrl, {
      method: 'PATCH',
      headers: {
        'Content-Type': 'application/json',
        Authorization: REST_API_SECRET,
      },
      body: JSON.stringify(document),
    })

    if (!response.ok) {
      if (response.status === 404) {
        // Document doesn't exist, try to create it
        const createResponse = await fetch(collabUrl, {
          method: 'POST',
          headers: {
            'Content-Type': 'application/json',
            Authorization: REST_API_SECRET,
          },
          body: JSON.stringify(document),
        })

        if (!createResponse.ok) {
          console.error(
            `Failed to create document: ${createResponse.status} ${createResponse.statusText}`,
          )
        }
      } else {
        console.error(`Failed to update document: ${response.status} ${response.statusText}`)
      }
    }
  } catch (error) {
    console.error('Error updating document:', error)
  }
}
```

### Complete example

Here's a complete example showing how to integrate schema awareness into an AI agent chatbot:

```tsx
// app/server-ai-agent-chatbot/page.tsx
'use client'

import { useChat } from '@ai-sdk/react'
import { Collaboration } from '@tiptap/extension-collaboration'
import { EditorContent, useEditor } from '@tiptap/react'
import StarterKit from '@tiptap/starter-kit'
import { TiptapCollabProvider } from '@tiptap-pro/provider'
import { getSchemaAwarenessData } from '@tiptap-pro/server-ai-toolkit'
import { DefaultChatTransport } from 'ai'
import { useEffect, useRef, useState } from 'react'
import { v4 as uuid } from 'uuid'
import * as Y from 'yjs'
import { getCollabConfig } from './actions'

export default function Page() {
  const [doc] = useState(() => new Y.Doc())
  const [documentId] = useState(() => `server-ai-agent-chatbot/${uuid()}`)
  const providerRef = useRef<TiptapCollabProvider | null>(null)

  const editor = useEditor({
    immediatelyRender: false,
    extensions: [StarterKit, CustomAlertExtension, Collaboration.configure({ document: doc })], // Include your custom extension
  })

  // Get JWT token and appId from server action
  useEffect(() => {
    const setupProvider = async () => {
      try {
        const { token, appId } = await getCollabConfig('user-1', documentId)

        const collabProvider = new TiptapCollabProvider({
          appId,
          name: documentId,
          token,
          document: doc,
          user: 'user-1',
          onOpen() {
            console.log('WebSocket connection opened.')
          },
          onConnect() {
            editor?.commands.setContent(initialContent)
          },
        })

        providerRef.current = collabProvider
      } catch (error) {
        console.error('Failed to setup collaboration:', error)
      }
    }

    setupProvider()

    return () => {
      if (providerRef.current) {
        providerRef.current.destroy()
        providerRef.current = null
      }
    }
  }, [documentId, doc, editor])

  // Fixes issue: https://github.com/vercel/ai/issues/7819
  // Get and send schema awareness data
  const schemaAwarenessData = editor ? getSchemaAwarenessData(editor) : null
  const schemaAwarenessDataRef = useRef(schemaAwarenessData)
  schemaAwarenessDataRef.current = schemaAwarenessData

  const { messages, sendMessage } = useChat({
    transport: new DefaultChatTransport({
      api: '/api/server-ai-agent-chatbot',
      body: () => ({
        schemaAwarenessData: schemaAwarenessDataRef.current,
        documentId,
      }),
    }),
  })

  // ... rest of component
}
```

```ts
// app/api/server-ai-agent-chatbot/route.ts
import { openai } from '@ai-sdk/openai'
import { createAgentUIStreamResponse, ToolLoopAgent, tool, type UIMessage } from 'ai'
import z from 'zod'
import { executeTool } from './execute-tool'
import { getDocument } from './get-document'
import { getSchemaAwarenessPrompt } from './get-schema-awareness-prompt'
import { getToolDefinitions } from './get-tool-definitions'
import { updateDocument } from './update-document'

export async function POST(req: Request) {
  const {
    messages,
    schemaAwarenessData,
    documentId,
  }: {
    messages: UIMessage[]
    schemaAwarenessData: unknown
    documentId: string
  } = await req.json()

  // Get tool definitions from the Server AI Toolkit API
  const toolDefinitions = await getToolDefinitions(schemaAwarenessData)

  // Get schema awareness prompt from the Server AI Toolkit API
  const schemaAwarenessPrompt = await getSchemaAwarenessPrompt(schemaAwarenessData)

  // Convert API tool definitions to AI SDK tool format
  const tools = Object.fromEntries(
    toolDefinitions.map((toolDef) => [
      toolDef.name,
      tool({
        description: toolDef.description,
        inputSchema: z.fromJSONSchema(toolDef.inputSchema),
        execute: async (input) => {
          try {
            // Get the latest version of the document before executing the tool
            const document = await getDocument(documentId)

            const result = await executeTool(
              toolDef.name,
              input,
              document,
              schemaAwarenessData, // Include schema awareness data
            )

            // Update the document after executing the tool if it changed
            if (result.docChanged && result.document && documentId) {
              await updateDocument(documentId, result.document)
            }

            return result.output
          } catch (error) {
            console.error(`Failed to execute tool ${toolDef.name}:`, error)
            return {
              error: error instanceof Error ? error.message : 'Unknown error',
            }
          }
        },
      }),
    ]),
  )

  const agent = new ToolLoopAgent({
    model: openai('gpt-5-mini'),
    instructions: `You are an assistant that can edit rich text documents.

${schemaAwarenessPrompt}`, // Include schema awareness prompt in instructions
    tools,
    providerOptions: {
      openai: {
        reasoningEffort: 'minimal',
      },
    },
  })

  return createAgentUIStreamResponse({
    agent,
    uiMessages: messages,
  })
}
```

You've now set up schema awareness for your AI model using the Server AI Toolkit.

## Next steps

- [Schema awareness API reference](/content-ai/capabilities/server-ai-toolkit/api-reference/schema-awareness)
- [REST API reference](/content-ai/capabilities/server-ai-toolkit/api-reference/rest-api)
